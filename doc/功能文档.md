# TrickleDown-TODOLIST 设计文档

> 张泽宇 2022012117 zhangzey22@mails.tsinghua.edu.cn

[TOC]

## 1. 用户类

### 1.1 用户类设计

> 这一部分主要由张泽宇完成

用户类是所有功能的基础。在充分考虑用户的需求后，我们进行了前端、后端和数据库共通的用户类设计，该用户类能够满足目前提供的所有功能，并为一些可能的拓展功能预留了接口。

前端的用户类如下：

```kotlin
package com.example.big
// user.kt
import android.graphics.Bitmap
import android.net.Uri
import java.util.Date

/**
 * 用户类，管理用户信息、状态和权限
 */
class User(// Getters
    // 基本用户信息
    val id: Int, // 用户ID
    // 用户名
    var username: String
) {
    // 用户状态枚举
    enum class UserStatus {
        LOGGED_OUT,  // 退出登录
        REGISTERED,  // 已注册但未登录
        LOGGED_IN // 已登录
    }

    // 权限类型
    enum class PermissionType {
        ALARM,  // 闹钟权限
        NOTIFICATION,  // 通知权限
        LOCATION,  // 位置权限
        STORAGE,  // 存储权限
        CALENDAR,  // 日历权限
        CONTACTS // 联系人权限
    }

    var nickname: String? = null // 昵称
        private set
    var email: String? = null // 邮箱
        private set
    var phoneNumber: String? = null // 手机号
        private set
    var avatar: Bitmap? = null // 头像（Bitmap格式）
        private set
    var avatarUri: Uri? = null // 头像URI
        private set
    var createdDate: Date? = null // 账户创建日期
        private set
    var lastLoginDate: Date? = null // 最后登录日期
        private set

    // 用户状态
    var status: UserStatus // 当前状态
        private set

    // 身份验证信息
    var token: String? = null // 登录令牌
        private set
    var tokenExpireDate: Date? = null // 令牌过期时间
        private set
    var refreshToken: String? = null // 刷新令牌
        private set

    // 用户偏好和设置
    private val permissions: MutableMap<PermissionType, Boolean> // 权限设置
    private val preferences: MutableMap<String, Any> // 其他用户偏好

    // 用户绑定的任务
    private val task_id: ArrayList<Int>? = null

    //构造函数（省略）

    //函数（省略）
}
```

在后端，我们设计了对应的用户类：

```go
// UserStatus 用户状态枚举
type UserStatus string

const (
	LoggedOut  UserStatus = "LOGGED_OUT"  // 退出登录
	Registered UserStatus = "REGISTERED"  // 已注册但未登录
	LoggedIn   UserStatus = "LOGGED_IN"   // 已登录
)

// PermissionType 权限类型枚举
type PermissionType string

const (
	Alarm        PermissionType = "ALARM"        // 闹钟权限
	Notification PermissionType = "NOTIFICATION" // 通知权限
	Location     PermissionType = "LOCATION"     // 位置权限
	Storage      PermissionType = "STORAGE"      // 存储权限
	Calendar     PermissionType = "CALENDAR"     // 日历权限
	Contacts     PermissionType = "CONTACTS"     // 联系人权限
)

// User 用户类，管理用户信息、状态和权限
type User struct {
	ID              primitive.ObjectID        `json:"id" bson:"_id,omitempty"`   // 用户ID
	Username        string                    `json:"username" bson:"username"`  // 用户名
	Nickname        string                    `json:"nickname" bson:"nickname"`  // 昵称
	Email           string                    `json:"email" bson:"email"`        // 邮箱
	PhoneNumber     string                    `json:"phoneNumber" bson:"phoneNumber"` // 手机号
	HashedPassword  string                    `json:"-" bson:"hashedPassword"`   // 加密后的密码
	AvatarURL       string                    `json:"avatarURL" bson:"avatarURL"` // 头像URL
	CreatedDate     time.Time                 `json:"createdDate" bson:"createdDate"` // 账户创建日期
	LastLoginDate   time.Time                 `json:"lastLoginDate" bson:"lastLoginDate,omitempty"` // 最后登录日期
	Status          UserStatus                `json:"status" bson:"status"`       // 当前状态
	Token           string                    `json:"-" bson:"token,omitempty"`   // 登录令牌
	TokenExpireDate time.Time                 `json:"-" bson:"tokenExpireDate,omitempty"` // 令牌过期时间
	RefreshToken    string                    `json:"-" bson:"refreshToken,omitempty"`   // 刷新令牌
	Permissions     map[PermissionType]bool   `json:"permissions" bson:"permissions"` // 权限设置
	Preferences     map[string]interface{}    `json:"preferences" bson:"preferences"` // 其他用户偏好
	TaskIDs         []primitive.ObjectID      `json:"taskIds" bson:"taskIds"` // 用户绑定的任务ID列表
	APIKey          string                    `json:"apiKey" bson:"apiKey"`  // API 密钥，用于 AI 服务
}
```

数据库中的一条用户记录如下：

```json
{
  "_id": {
    "$oid": "680f08e28af62d8cf71fea4f"
  },
  "username": "ggc",
  "nickname": "GKing910",
  "email": "236923330@qq.com",
  "phoneNumber": "13683129567",
  "hashedPassword": "$2a$14$Aa7KyGsI.pAEtlZwLI596eWxzNRClaSunxedsvSeCifAkBvtY/jTW",
  "avatarURL": "/api/avatars/1747202505081149741.jpg",
  "createdDate": {
    "$date": "2025-04-28T04:49:38.840Z"
  },
  "lastLoginDate": {
    "$date": "2025-05-14T05:59:46.724Z"
  },
  "status": "LOGGED_IN",
  "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjoxNzQ1ODE1Nzc4LCJpc3MiOiJ0b2RvLWFwcCIsInN1YiI6IjE3NDU4MTU3NzgiLCJleHAiOjE3NDcyODg3ODYsIm5iZiI6MTc0NzIwMjM4NiwiaWF0IjoxNzQ3MjAyMzg2fQ.8r1iGD7Ua_yfXL0QbKSaclQXSkqrwXJ2Do7W9PjwMgQ",
  "tokenExpireDate": {
    "$date": "2025-05-15T05:59:46.724Z"
  },
  "refreshToken": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjoxNzQ1ODE1Nzc4LCJpc3MiOiJ0b2RvLWFwcCIsInN1YiI6IjE3NDU4MTU3NzgiLCJleHAiOjE3NDc4MDcxODYsIm5iZiI6MTc0NzIwMjM4NiwiaWF0IjoxNzQ3MjAyMzg2fQ.TDlMl_3oVRqcg5YZEwBukM2CMRZjnCqudMM-5be3Tnw",
  "permissions": {
    "NOTIFICATION": false,
    "LOCATION": false,
    "STORAGE": false,
    "CALENDAR": false,
    "CONTACTS": false,
    "ALARM": false
  },
  "preferences": {},
  "taskIds": [],
  "apiKey": "sk-27d5bc6ca6824cad8679e5e67e85b2ff"
}
```

我们对用户的id、密码均进行了严格的哈希加密，确保敏感信息不会出现在前端。对于apikey，我们使用了按token授权访问的方式，确保前端只有在用户登录时能够临时获取apikey，在一定程度上能够保护apikey不受泄露。

### 1.2 用户的注册，登录与登出

> 这一部分主要由张泽宇完成

对于未授权的暴露接口，我们使用了基于Retrofit2的`ApiClient.kt`和`ApiService.kt`进行管理，这一部分的关键代码如下：

```kotlin
//api/ApiService.kt
interface ApiService {
    @POST("api/register")
    suspend fun registerUser(@Body request: RegisterRequest): Response<AuthResponse>

    @POST("api/login")
    suspend fun loginUser(@Body request: LoginRequest): Response<AuthResponse>
}
```

基于此，用户注册的流程如下：

```mermaid
sequenceDiagram

  Frontend->>+Backend: POST /api/register {username, password, ...}

  Backend->>+MongoDB: 检查用户名是否存在

  MongoDB-->>-Backend: 返回结果

  Backend->>Backend: 哈希密码

  Backend->>+MongoDB: 创建新用户

  MongoDB-->>-Backend: 返回用户数据

  Backend->>Backend: 生成JWT令牌 (access & refresh)

  Backend-->>-Frontend: 返回用户信息和令牌

  Frontend->>Frontend: 存储令牌和用户信息

```

用户登录的流程如下：

```mermaid
sequenceDiagram
    Frontend->>+Backend: POST /api/login {username, password}
    Backend->>+MongoDB: 查找用户
    MongoDB-->>-Backend: 返回用户数据
    Backend->>Backend: 验证密码
    Backend->>Backend: 生成JWT令牌 (access & refresh)
    Backend->>+MongoDB: 更新用户登录状态
    MongoDB-->>-Backend: 确认更新
    Backend-->>-Frontend: 返回用户信息和令牌
    Frontend->>Frontend: 存储令牌和用户信息
```

对于用户登出，这是一个需要授权请求头的接口，因此我们将其放在`UserApiService.kt`中进行统一管理：

```kotlin
    @POST("api/logout")
    suspend fun logout(): Response<Map<String, String>> //将清除用户的登录状态和临时token
```

同时，为确保登录/注册页面能够在用户进入应用后加载成功，我们设计了纯Compose的`AuthScreen.kt`，在此处进行页面的加载和监听。

### 1.3 用户的验证

> 这一部分主要由张泽宇完成

为确保用户认证正确，我们实现了用户的双重认证方法，HashPassword（用于登录）和JwtTokens（用于授权Api的请求头）

密码部分的核心代码是：

```go
//password.go
// HashPassword 对密码进行哈希处理
func HashPassword(password string) (string, error) {
	bytes, err := bcrypt.GenerateFromPassword([]byte(password), 14)
	return string(bytes), err
}

// CheckPassword 验证密码是否匹配哈希值
func CheckPassword(hashedPassword, password string) error {
	return bcrypt.CompareHashAndPassword([]byte(hashedPassword), []byte(password))
}
```

Token部分的核心代码包括：

+ `func GenerateAccessToken(userID uint) (string, error)`：生成访问所用的令牌
+ `func GenerateRefreshToken(userID uint) (string, error)`：刷新令牌
+ `func ValidateToken(tokenString string) (*jwt.RegisteredClaims, error)`：验证令牌
+ `func GetUserIDFromToken(tokenString string) (uint, error)`：从令牌中访问用户ID

认证中间件核心实现为：

```go
// AuthMiddleware JWT认证中间件
func AuthMiddleware() gin.HandlerFunc {
	return func(c *gin.Context) {
		authHeader := c.GetHeader("Authorization")
		if authHeader == "" {
			c.JSON(http.StatusUnauthorized, gin.H{"error": "Authorization header is required"})
			c.Abort()
			return
		}
		
		// 检查格式: "Bearer {token}"
		parts := strings.Split(authHeader, " ")
		if len(parts) != 2 || parts[0] != "Bearer" {
			c.JSON(http.StatusUnauthorized, gin.H{"error": "Authorization header format must be Bearer {token}"})
			c.Abort()
			return
		}
		
		// 验证token
		claims, err := utils.ValidateToken(parts[1])
		if err != nil {
			c.JSON(http.StatusUnauthorized, gin.H{
				"error": fmt.Sprintf("Invalid or expired token: %v", err),
			})
			c.Abort()
			return
		}
		
		// 将用户ID添加到上下文
		c.Set("userID", claims.Subject)
		c.Next()
	}
}
```



刷新token中间件核心实现为：

```go
// TokenRefreshMiddleware Token自动续期中间件
func TokenRefreshMiddleware(userRepo *repositories.UserRepository) gin.HandlerFunc {
    return func(c *gin.Context) {
        // 先执行请求
        c.Next()
        
        // 只处理成功的请求
        if c.Writer.Status() >= 200 && c.Writer.Status() < 300 {
            // 获取并验证Authorization头
            authHeader := c.GetHeader("Authorization")
            if authHeader == "" {
                return
            }
            
            parts := strings.Split(authHeader, " ")
            if len(parts) != 2 || parts[0] != "Bearer" {
                return
            }
            
            token := parts[1]
            
            // 解析token
            claims, err := utils.ValidateToken(token)
            if err != nil {
                return // token无效，不处理
            }
            
            // 获取用户ID
            userIDStr := claims.Subject
            userIDInt, err := strconv.ParseInt(userIDStr, 10, 64)
            if err != nil {
                return
            }
            
            // 构造ObjectID
            objectIDBytes := make([]byte, 12)
            binary.BigEndian.PutUint32(objectIDBytes[0:4], uint32(userIDInt))
            objectID := primitive.ObjectID(objectIDBytes)
            
            // 获取用户
            user, err := userRepo.FindByID(objectID)
            if err != nil {
                return
            }
            
            // 检查token是否快过期 
            currentTime := time.Now()
            if user.TokenExpireDate.Sub(currentTime) < 12*time.Hour {
                // 生成新token
                newAccessToken, _ := utils.GenerateAccessToken(uint(userIDInt))
                newRefreshToken, _ := utils.GenerateRefreshToken(uint(userIDInt))
                
                accessTokenDuration := 24 * time.Hour
                user.RefreshUserToken(newAccessToken, currentTime.Add(accessTokenDuration), newRefreshToken)
                
                userRepo.Update(user)
                
                // 在响应头中设置新token
                c.Header("X-New-Access-Token", newAccessToken)
                c.Header("X-New-Refresh-Token", newRefreshToken)
                c.Header("X-Token-Expires-In", "86400") // 24小时(秒)
            }
        }
    }
}
```

最终，我们实现的认证逻辑为：

```mermaid

sequenceDiagram
    Frontend->>+Backend: POST /api/refresh {refreshToken}
    Backend->>Backend: 验证刷新令牌
    Backend->>Backend: 生成新的访问令牌
    Backend->>+MongoDB: 更新用户令牌
    MongoDB-->>-Backend: 确认更新
    Backend-->>-Frontend: 返回新令牌
    Frontend->>Frontend: 更新存储的令牌

```

在前端api中的实现是：

```kotlin
//TaskApiClient.kt    
// 创建认证拦截器
    private val authInterceptor = object : Interceptor {
        override fun intercept(chain: Interceptor.Chain): Response {
            val originalRequest = chain.request()
            val token = TokenManager.getAccessToken()

            // 如果有令牌，添加到请求头中
            return if (token != null) {
                val newRequest = originalRequest.newBuilder()
                    .header("Authorization", "Bearer $token")
                    .build()
                chain.proceed(newRequest)
            } else {
                chain.proceed(originalRequest)
            }
        }
    }
```

### 1.4 用户信息管理

和用户信息管理相关的API集成在`UserApiService.kt`中，具体而言，包括：

```kotlin
interface UserApiService {
    @GET("api/users/{id}")
    suspend fun getUser(@Path("id") userId: String): Response<UserResponse>

    @PUT("api/users/{id}")
    suspend fun updateUser(
        @Path("id") userId: String,
        @Body updateRequest: UpdateUserRequest
    ): Response<UserResponse>

    @Multipart
    @POST("api/users/{id}/avatar")
    suspend fun uploadAvatar(
        @Path("id") userId: String,
        @Part avatar: MultipartBody.Part
    ): Response<Map<String, String>>

    @PUT("api/users/{id}/apikey")
    suspend fun updateApiKey(
        @Path("id") userId: String,
        @Body updateRequest: UpdateApiKeyRequest
    ): Response<Map<String, String>>

    // 修改为包含用户ID的路径
    @POST("api/ai/suggestion/{userId}")
    suspend fun getAISuggestion(
        @Path("userId") userId: String,
        @Body request: AISuggestionRequest
    ): Response<AISuggestionResponse>

    // 添加新的权限相关方法
    @GET("api/users/{id}/permissions")
    suspend fun getUserPermissions(@Path("id") userId: String): Response<Map<String, Boolean>>

    @PUT("api/users/{id}/permissions")
    suspend fun updateUserPermission(
        @Path("id") userId: String,
        @Body request: UserPermissionRequest
    ): Response<Map<String, String>>
}
```

对于所有对用户信息的管理，我们遵循基本的处理方式：

+ `routes.go`对前端请求的API进行导航

+ `user_controller.go`对API传递的数据进行分析，并传入后端
+ `user_repositories.go`将需要更改的数据导入到数据库中
+ `user_controller.go`将更改后的数据反馈至前端

对于大文件（如用户头像图片），我们在服务器上划分了专门的区域存放，通过在API中传递URL实现非流式加载。

## 2. 任务类

### 2.1 任务类设计

> 这一部分由葛冠辰、张泽宇完成

对于TODOLIST应用中所有的任务，我们统一采用Task类进行管理。Task类的基本实现如下：

```kotlin
//task.kt
class Task {
    var id: String
        private set
    var title: String
        private set
    var timeRange: String
        private set
    var date: Date
        private set
    var durationMinutes: Int
        private set
    var isImportant: Boolean
        private set
    var description: String? = null
        private set
    //关联用户
    private val user_id = 0
    //倒计时
    var dueDate: Date? = null
    //地点
    var place: String? = null
    //是否完成
    var isFinished: Boolean = false
    //是否拖延
    var isDelayed: Boolean = false
    //与别的任务存在时间重叠的个数
    private val layers = 0
    //从属的类别（如果有）
    var category: String? = null
    //函数（省略）
}
```

类似于User类，我们在后端实现了Task相关的一整套路由和管理文件。值得提出的是，一开始我们没有规范Task中与时间相关的内容，这引发了用户时区等一系列问题，因此最终我们统一使用`Date`格式存储时间，对于用户输入的字符串，则使用`json`分析器进行处理。最终数据库中的任务格式如下：

```json
{
  "_id": {
    "$oid": "6819e4558af62d8cf71fea5b"
  },
  "user_id": "680f08e28af62d8cf71fea4f",
  "title": "安卓开发",
  "time_range": "00:00 - 00:00",
  "date": {
    "$date": "2025-05-07T00:00:00.974Z"
  },
  "duration_minutes": 0,
  "is_important": true,
  "due_date": {
    "$date": "2025-05-07T00:00:00.974Z"
  },
  "is_finished": true,
  "is_delayed": false,
  "category": "学习",
  "created_at": {
    "$date": "2025-05-06T10:28:37.694Z"
  },
  "updated_at": {
    "$date": "2025-05-07T05:39:31.377Z"
  }
}
```

### 2.2 任务的获取和筛选

> 这一部分由葛冠辰、张泽宇完成

我们在`TaskApiService.kt`中实现了如下所示的API：

```kotlin
//TaskApiService.kt    
@GET("api/tasks/users/{userId}")
    suspend fun getAllTasks(
        @Path("userId") userId: String,
        @Query("page") page: Int = 1,
        @Query("limit") limit: Int = 10
    ): Response<TaskListResponse>

    // 获取任务详情
    @GET("api/tasks/{taskId}")
    suspend fun getTask(@Path("taskId") taskId: String): Response<TaskResponse>

    // 创建任务
    @POST("api/tasks/users/{userId}")
    suspend fun createTask(
        @Path("userId") userId: String,
        @Body request: CreateTaskRequest
    ): Response<CreateTaskResponse>

    // 更新任务
    @PUT("api/tasks/{taskId}")
    suspend fun updateTask(
        @Path("taskId") taskId: String,
        @Body request: CreateTaskRequest
    ): Response<TaskResponse>

    // 删除任务
    @DELETE("api/tasks/{taskId}")
    suspend fun deleteTask(@Path("taskId") taskId: String): Response<Map<String, String>>

    // 切换任务完成状态
    @PATCH("api/tasks/{taskId}/toggle")
    suspend fun toggleTaskFinished(@Path("taskId") taskId: String): Response<TaskResponse>

    // 按分类获取任务
    @GET("api/tasks/users/{userId}")
    suspend fun getTasksByCategory(
        @Path("userId") userId: String,
        @Query("category") category: String
    ): Response<TaskListResponse>

    // 按日期获取任务
    @GET("api/tasks/users/{userId}/today")
    suspend fun getTasksByDate(
        @Path("userId") userId: String,
        @Query("date") date: String
    ): Response<List<TaskResponse>>
```

对于数据的传递，我们建立了`TaskModel.kt`，规范了任务相关API的标准请求与返回格式：

```kotlin
// 用于创建和更新任务的请求模型
data class CreateTaskRequest(
    val title: String,
    val time_range: String,  // 使用下划线命名以匹配后端
    val date: Date,
    val duration_minutes: Int,  // 使用下划线命名以匹配后端
    val is_important: Boolean,  // 使用下划线命名以匹配后端
    val description: String? = null,
    val place: String? = null,
    val due_date: Date? = null,  // 使用下划线命名以匹配后端
    val category: String? = null,
    val is_finished: Boolean = false,  // 使用下划线命名以匹配后端
    val is_delayed: Boolean = false
)

// 服务器响应的任务模型
data class TaskResponse(
    val id: String,  // 使用String类型匹配MongoDB的ObjectID
    val user_id: String,  // 使用下划线命名以匹配后端
    val title: String,
    val time_range: String,  // 使用下划线命名以匹配后端
    val date: Date,
    val duration_minutes: Int,  // 使用下划线命名以匹配后端
    val is_important: Boolean,  // 使用下划线命名以匹配后端
    val description: String? = null,
    val place: String? = null,
    val due_date: Date? = null,  // 使用下划线命名以匹配后端
    val category: String? = null,
    val is_finished: Boolean = false,  // 使用下划线命名以匹配后端
    val is_delayed: Boolean = false,  // 使用下划线命名以匹配后端
    val created_at: Date,  // 使用下划线命名以匹配后端
    val updated_at: Date  // 使用下划线命名以匹配后端
)
```

在此基础上，任务的获取和筛选都可以按以下的程序进行：

+ **获取用户的全部/今天/某一类别任务**。这一部分通过数据库的query进行，因此能够实现高效查询。同时我们在合适的区域实现了类似流的分页传输数据，由此可以对任务的前端加载进行优化。
+ **在前端对任务进行进一步筛选**。由于response中都有明确的key值，前端可以在获取任务的同时进行筛选，只显示用户需要筛选的任务。

### 2.3 任务信息的修改

> 这一部分由葛冠辰、张泽宇完成

这一部分主要与任务的创建和编辑相关。在前端，2.2部分中的API可以充分适应创建和编辑任务需要的功能。

在后端，创建任务的核心代码是：

```go
//task_controller.go
// CreateTask 创建一个新任务
func (c *TaskController) CreateTask(ctx *gin.Context) {
    userID := ctx.Param("user_id")
    if userID == "" {
        ctx.JSON(http.StatusBadRequest, gin.H{"error": "用户ID不能为空"})
        return
    }
    
    var taskInput models.TaskInput
    if err := ctx.ShouldBindJSON(&taskInput); err != nil {
        ctx.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
        return
    }
    
    task := &models.Task{
        UserID:         userID,
        Title:          taskInput.Title,
        TimeRange:      taskInput.TimeRange,
        Date:           taskInput.Date,
        DurationMinutes: taskInput.DurationMinutes,
        IsImportant:    taskInput.IsImportant,
        Description:    taskInput.Description,
        DueDate:        taskInput.DueDate,
        Place:          taskInput.Place,
        IsFinished:     false,
        IsDelayed:      false,
        Category:       taskInput.Category,
    }
    
    taskID, err := c.taskRepo.Create(ctx, task)
    if err != nil {
        ctx.JSON(http.StatusInternalServerError, gin.H{"error": "创建任务失败"})
        return
    }
    
    ctx.JSON(http.StatusCreated, gin.H{
        "task_id": taskID,
        "message": "任务创建成功",
    })
}
```

编辑任务的核心代码是：

```go
//task_controller.go
// UpdateTask 更新任务
func (c *TaskController) UpdateTask(ctx *gin.Context) {
    taskID := ctx.Param("task_id")
    if taskID == "" {
        ctx.JSON(http.StatusBadRequest, gin.H{"error": "任务ID不能为空"})
        return
    }
    
    // 先获取原有任务
    existingTask, err := c.taskRepo.GetByID(ctx, taskID)
    if err != nil {
        ctx.JSON(http.StatusNotFound, gin.H{"error": "任务不存在"})
        return
    }
    
    var taskInput models.TaskInput
    if err := ctx.ShouldBindJSON(&taskInput); err != nil {
        ctx.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
        return
    }
    
    // 更新任务字段
    existingTask.Title = taskInput.Title
    existingTask.TimeRange = taskInput.TimeRange
    existingTask.Date = taskInput.Date
    existingTask.DurationMinutes = taskInput.DurationMinutes
    existingTask.IsImportant = taskInput.IsImportant
    existingTask.Description = taskInput.Description
    existingTask.DueDate = taskInput.DueDate
    existingTask.Place = taskInput.Place
    existingTask.Category = taskInput.Category
    
    if err := c.taskRepo.Update(ctx, taskID, existingTask); err != nil {
        ctx.JSON(http.StatusInternalServerError, gin.H{"error": "更新任务失败"})
        return
    }
    
    ctx.JSON(http.StatusOK, gin.H{"message": "任务更新成功"})
}
```

### 2.4 任务图形界面

> 这一部分主要由葛冠辰完成

#### 2.4.1 图形化设置

为实现任务图形界面，我们主要使用了两个模块：

+ `KanbanViewActivity.kt`：在这个模块中，我们定义了需要的compose组件和重要的辅助函数：
  + `DateSelectionBar`：上方的日期栏，`OnDrag`监听移动日期，`Onclick`监听进入日期详细页面
  + `MultiDayTimelineView`：指定时间任务卡片的父组件，包括时间轴
  + `NoTimeTasksSection`：未指定时间任务卡片的父组件
  + `DraggableTaskCard`：指定时间任务卡片，包含核心的`OnDrag`监听和`OnClick`监听
  + `SimpleTaskCard`：未指定时间任务卡片，设定为不可移动
+ `KanbanTimelineAdapter.kt`：时间-坐标转换的关键函数

#### 2.4.2 移动流程

任务卡片的移动如图所示：

```mermaid
sequenceDiagram
    participant User as 用户
    participant TaskCard as DraggableTaskCard
    participant KanbanScreen as KanbanScreen
    participant KanbanActivity as KanbanViewActivityCompose
    participant UpdateTask as updateTaskTime函数
    participant TaskManager as TaskManager
    participant Backend as 后端API

    User->>TaskCard: 长按并拖动任务卡片
    
    TaskCard->>TaskCard: 启动拖动检测<br>detectDragGestures
    Note over TaskCard: 记录初始状态<br>isDragging = true<br>KanbanDragState.currentDraggingId 设置
    
    loop 拖动过程
        User->>TaskCard: 移动手指
        TaskCard->>TaskCard: onDrag 回调
        TaskCard->>TaskCard: 更新 offsetX/offsetY
        TaskCard->>TaskCard: 计算新日期和时间
        TaskCard->>TaskCard: 更新预览状态<br>previewDate, previewTimeRange<br>calculatedStartMinutes, calculatedEndMinutes
        TaskCard->>TaskCard: 更新视觉反馈
    end
    
    User->>TaskCard: 释放手指
    TaskCard->>TaskCard: onDragEnd 回调
    
    alt 只是点击(没有实质性移动)
        TaskCard->>TaskCard: 重置状态<br>resetCard()
        TaskCard->>KanbanScreen: 调用 onEditTask 回调
        KanbanScreen->>KanbanActivity: 启动 EditTaskActivity
    else 有效的拖动操作
        TaskCard->>TaskCard: 记录最终位置和动画状态<br>isAnimating = true
        
        par 并行执行
            TaskCard->>TaskCard: 执行回弹动画<br>animatedOffsetX/Y.animateTo(0f)
            
            TaskCard->>UpdateTask: 调用 updateTaskTime 函数<br>传递任务和新位置信息
            
            UpdateTask->>UpdateTask: 计算新的时间范围<br>创建预览任务对象
            UpdateTask->>TaskManager: 获取最新任务<br>getLatestTasksFromServer
            TaskManager->>Backend: 发送 GET 请求获取任务列表
            Backend->>TaskManager: 返回任务列表
            
            UpdateTask->>UpdateTask: 检查时间冲突
            
            alt 存在冲突
                UpdateTask->>UpdateTask: 显示冲突信息<br>onUpdateMessage
                UpdateTask->>TaskCard: 重置任务位置
            else 无冲突
                UpdateTask->>TaskCard: 更新本地UI<br>onTasksUpdated
                
                UpdateTask->>UpdateTask: 准备更新请求
                UpdateTask->>TaskManager: 调用 updateTask
                
                TaskManager->>Backend: 发送 PUT 请求<br>/api/tasks/{taskId}
                Note over TaskManager,Backend: 包含新的日期和时间信息
                
                Backend->>TaskManager: 返回更新后的任务
                
                TaskManager->>UpdateTask: 返回更新结果
                
                alt 更新成功
                    UpdateTask->>KanbanScreen: 调用 onRefreshNeeded 回调
                    KanbanScreen->>KanbanActivity: refreshKanbanView() 
                    KanbanActivity->>KanbanActivity: onDragRefreshNeeded()
                    KanbanActivity->>KanbanActivity: refreshTrigger.value++
                    KanbanActivity->>KanbanScreen: 重新加载任务<br>(LaunchedEffect触发)
                    KanbanScreen->>TaskManager: 重新获取任务
                    TaskManager->>Backend: GET 请求获取最新任务
                    Backend->>TaskManager: 返回最新任务
                    TaskManager->>KanbanScreen: 更新任务列表
                else 更新失败
                    UpdateTask->>TaskCard: 恢复原始状态<br>onTasksUpdated(originalTasksList)
                    UpdateTask->>UpdateTask: 显示错误信息<br>onUpdateMessage
                end
            end
        end
    end
    
    TaskCard->>TaskCard: 完成动画<br>isAnimating = false<br>isDragging = false
    TaskCard->>TaskCard: 重置状态变量
```

### 2.5 大模型对话

> 这一部分主要由张泽宇完成

由于deepseek等常用的llm一般并不支持从前端直接访问，首先需要根据deepseek的官方文档定义以下结构体以管理与ai相关的API：

```go
type AIRequest struct {
    TaskID          string `json:"task_id" binding:"required"`
    DetailedPrompts string `json:"detailed_prompts"`
}

type DeepseekMessage struct {
    Role    string `json:"role"`
    Content string `json:"content"`
}

type DeepseekRequest struct {
    Model       string            `json:"model"`
    Messages    []DeepseekMessage `json:"messages"`
    Temperature float64           `json:"temperature"`
    MaxTokens   int               `json:"max_tokens"`
}

type DeepseekChoice struct {
    Message      DeepseekMessage `json:"message"`
    FinishReason string          `json:"finish_reason"`
}

type DeepseekResponse struct {
    ID      string           `json:"id"`
    Object  string           `json:"object"`
    Created int64            `json:"created"`
    Choices []DeepseekChoice `json:"choices"`
    Usage   struct {
        PromptTokens     int `json:"prompt_tokens"`
        CompletionTokens int `json:"completion_tokens"`
        TotalTokens      int `json:"total_tokens"`
    } `json:"usage"`
}
```

之后，我们将充分利用任务的信息构造prompt：

```go
//ai_controller.go
    // 构建提示词
    currentTime := time.Now().Format("2006-01-02 15:04")
    
    prompt := fmt.Sprintf("现在是%s，我计划在%s于%s前完成%s，", 
                         currentTime, 
                         task.Place, 
                         task.Date.Format("2006-01-02 15:04"), 
                         task.Title)
    
    if task.Description != "" {
        prompt += fmt.Sprintf("其详细是%s，", task.Description)
    }
    
    if request.DetailedPrompts != "" {
        prompt += fmt.Sprintf("详细信息是%s，", request.DetailedPrompts)
    }
    
    if task.Category != "" {
        prompt += fmt.Sprintf("这个任务属于%s类别，", task.Category)
    }
    
    isCompleted := "已经完成"
    if !task.IsFinished {
        isCompleted = "尚未完成"
    }
    prompt += "目前" + isCompleted + "。"
    
    prompt += `
请给我一些关于这个任务的建议，注意要求：
1. 必须使用纯文本格式，不要使用任何Markdown语法（如*加粗*、_斜体_、#标题等）
2. 使用平实的聊天语气
3. 直接给出建议，不要添加"以下是我的建议"之类的开场白
4. 不要在回复结尾添加"需要更多帮助吗"、"还有其他问题吗"之类的结束语
5. 回答需要提供建议视角，尽量有条理
    `
```

最后，需要在前端添加apikey相关的获取和展示通道，并添加AI回复的展示框，即可完成该AI功能。

## 3. 云端支持

### 3.1 网络

> 这一部分由张泽宇负责

在进行该工作之前，我们已有一个运行在`dechelper.com`对应IP地址的后端。我们决定将该域名的子域名`todo.dechelper.com`作为本次作业的后端域名，因此首先需要配置Caddy作为反向代理：

```c
//Caddyfile
# 新增子域名配置
todo.dechelper.com {
    reverse_proxy nginx:80
}
```

第二步，在已有的docker配置中添加所需要的容器和网络

```dockerfile
    # 新增的 Todo 应用服务
  todo-app:
    container_name: todo_app_container
    build:
      context: ./todo-app
      dockerfile: Dockerfile
    environment:
      - DB_HOST=todo-db
      - DB_PORT=3306
      - DB_USER=root
      - DB_PASSWORD=TODOpassword
      - DB_NAME=todo_db
      - BASE_URL=https://todo.dechelper.com
    depends_on:
      todo-db:
        condition: service_healthy
    networks:
      - todo_backend
      - frontend  # 需要与nginx在同一网络
    restart: on-failure
    volumes:
      - ./todo-app/upload:/app/upload

  # 新增的 Todo 数据库服务
  todo-db:
    image: mysql:8.0
    container_name: todo_mysql_container
    ports:
      - "3308:3306"  # 使用不同端口避免冲突
    environment:
      MYSQL_ROOT_PASSWORD: TODOpassword
      MYSQL_DATABASE: todo_db
    volumes:
      - todo_db_data:/var/lib/mysql
    networks:
      - todo_backend
    healthcheck:
      test: ["CMD", "mysqladmin", "ping", "-h", "localhost"]
      interval: 10s
      timeout: 5s
      retries: 5
```

随后，使用nginx服务配置中间层：

```nginx
events {}

http {
#原有的server（省略）

        # 新增的Todo应用服务配置
    server {
        listen 80;
        server_name todo.dechelper.com;  # 新服务的子域名

        # 转发请求到Todo应用
        location / {
            proxy_pass http://todo-app:8080;  # 注意服务名要与docker-compose.yml中定义的一致
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        }
    }
}
```

最终，我们使用docker将容器部署在服务器上：

```yaml
# todo-app/Dockerfile

# Use Go image - 使用与原项目相同版本以保持一致性
FROM golang:1.24

# Set the working directory inside the container
WORKDIR /app

# Copy the Go module files
COPY go.mod go.sum ./

# Copy vendor
COPY vendor/ vendor/
ENV GOPROXY=off
ENV GOFLAGS=-mod=vendor
ENV TZ=Asia/Shanghai

# Copy the application source code
COPY . .

# Create necessary directories
RUN mkdir -p /app/upload/avatars

# Expose the application port
EXPOSE 8080

# 根据您的应用程序结构调整启动命令
CMD ["go", "run", "main.go"]
```

### 3.2 数据库连接

由于MongoDB数据库是非关系型数据库，不需要对其进行复杂的sql设置。

只需要在云服务器上部署数据库，并在`database.go`中实现与数据库的连接：

```go
var DB *mongo.Database

// ConnectDB 连接到MongoDB
func ConnectDB() {
    // 设置客户端连接配置
    clientOptions := options.Client().ApplyURI("mongodb://root:mango12345678@43.138.108.202:27017/admin")
    
    // 连接到MongoDB
    ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
    defer cancel()
    
    client, err := mongo.Connect(ctx, clientOptions)
    if err != nil {
        log.Fatal(err)
    }
    
    // 检查连接
    err = client.Ping(ctx, nil)
    if err != nil {
        log.Fatal(err)
    }
    
    log.Println("Connected to MongoDB!")
    
    // 获取数据库实例
    DB = client.Database("admin")
}

// GetCollection 获取集合
func GetCollection(collectionName string) *mongo.Collection {
    return DB.Collection(collectionName)
}
```

之后在`main.go`中使用数据库，即可使用数据库：

```go
// 连接到MongoDB
func connectToMongoDB() (*mongo.Client, error) {
    ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
    defer cancel()
    
    // 从环境变量获取MongoDB URI
    mongoURI := os.Getenv("MONGO_URI")
    if mongoURI == "" {
        // 默认使用之前的连接字符串
        mongoURI = "mongodb://root:mango12345678@43.138.108.202:27017/admin"
    }
    
    // 设置客户端连接配置
    clientOptions := options.Client().ApplyURI(mongoURI)
    
    // 连接到MongoDB
    client, err := mongo.Connect(ctx, clientOptions)
    if err != nil {
        return nil, err
    }
    
    // 检查连接
    err = client.Ping(ctx, nil)
    if err != nil {
        return nil, err
    }
    
    log.Println("Connected to MongoDB!")
    return client, nil
}
```

## 4. 第三方工作

### 4.1 库

本作业使用了如下库：
+ 网络请求
    + Retrofit: 2.11.0（HTTP客户端）
    + OkHttp: 4.12.0（HTTP客户端基础库）
    + OkHttp Logging Interceptor: 4.12.0（网络日志拦截器）
+ 图像加载和显示
    + Glide: 4.15.1（图片加载库）
    + Coil Compose: 2.4.0（Kotlin协程图片加载库）
    + CircleImageView: 3.1.0（圆形图片视图）
+ 图表
    + MPAndroidChart: v3.1.0（图表库）
+ UI
    + Compose BOM: 2024.04.00（Compose依赖版本管理）
    + Compose Material Icons Extended: 1.6.0/1.8.1（扩展图标库）
    + Compose Runtime LiveData: 1.8.0（LiveData与Compose集成）
+ 辅助功能
    + Google Generative AI: 0.9.0（生成式AI客户端库）
+ 协程
    + Kotlinx Coroutines Android: 1.10.2（Android平台协程库）

### 4.2 大模型
本次作业询问了大模型如下问题：
#### 4.2.1 Claude-3.7-Sonnet
指导gin/gorm后端的搭建和与原有后端的兼容（未直接使用大模型提供的代码）
1. 
> 我正在开发一个后端项目，目前我已经完成了以下工作：
> 1.在@\backend文件夹中添加了gin/gorm的依赖（也就是目前有go.sum和go.mod文件）
> 2.建立了MongoDB数据库mongodb://root:mango12345678@43.138.108.202:27017/admin
> 下一步我应该如何搭建使用MongoDB的go后端？
5. 
> 如果还是采取修改原有nginx.conf文件的方案（这个文件位于原有服务的path/backend/文件夹下，和原有服务的Dockerfile和docker-compose.yml等文件处于同一层目录），我是否需要调整文件结构使nginx.conf能够将新的子域名导向正确的后端服务？

API的快速设计，包括Header、Body、Response的快速实现（使用了部分AI代码）
2. 
> 你能否根据我给出的user.java,user.go和user_controller.go，构建以下api
>（1）用户的CRUD（按用户id）
>（2）获取/改变用户状态
>（3）获取/改变权限类型
>（4）获取/改变基本用户信息（除用户id和username）
> 4.1 获取用户id
> 4.2 获取username
>（5）username和id的随机生成（或许需要使用user_util.go）
>（6）jwt_token的生成和检验（或许需要使用jwt_util.go）
>（7）获取/更改用户的task列表
> （文件）
3. 
> 感谢你的帮助。如果我需要在这个用户管理系统上实现以下登录流程api，应该怎样修改对应的文件？
>（1）新注册用户设置用户名和密码（可以借用我给出的RegisterUser实现）
>（2）用户登录时，查验输入的用户名和密码
>（3）如果登录成功，返回用户信息和对应的jwt_token，并激活token自更新程序
> （文件）
4. 
> task
> 感谢你的帮助，现在后端已经正常运行。
> 现在请你参考(Task.kt)中的类，完成以下API设计
> edit task
> 1.添加新事项
> 输入用户id和事项信息，返回事项id和确认码
> 2.查看事项
> 输入事项id，返回事项信息
> 3.修改事项
> 输入事项id和新的事项信息，返回确认码
> 4.查看今日事项
> 输入用户id和日期，返回所有符合要求的事项的全部信息（包括id）
> 5.查看全部事项
> 输入用户id，按时间顺序返回所有事项的全部信息（考虑分页缓存处理）
> 6.筛选今日事项
> 输入用户id、日期和筛选条件（全部、未完成、重要、按时间、按类别），返回所有符合要求的事项的全部信息（包括id）
> 7.筛选全部事项
> 输入用户id和筛选条件（全部、未完成、重要、按时间、按类别），返回所有符合要求的事项的全部信息（包括id）
> 8.搜索全部事项
> 输入用户id和查询key，返回所有模糊匹配的事项的全部信息（包括id）
> task data
> 9.今日专注
> 输入用户id和日期，返回专注次数、时长、完成任务数量
> 10.累计专注
> 输入用户id，返回专注次数、时长、日均时长
> 11.专注时长分布
> 输入用户id和时间范围（日、周、月），返回时长分布
> tips
> 如果你需要我提供其他文件，请在回答中指出。
>
> （文件）

5. 

> ## task
>
> 请你仿照之前User部分的结构，实现task相关的api文件：
>
> - TaskApiClient
> - TaskApiService
> - TaskModel
>    以及其他的Manager等文件。
>
> ## tips
>
> AddTaskActivity用于添加任务，请在这个文件中添加api的调用示例。

14. 

> ## task
>
> 这是一个Gin/Gorm结构后端的User部分，请你添加以下api
>
> - 上传用户头像
> - 更改用户头像
> - 获取用户头像

修改部分函数（此处必须指出，AI在完成我们的创新功能方面几乎没有起到作用。）

6. 

> 你做得非常好。现在，你需要修改MainActivity中的函数，以筛选用户今日重要事项。
>  你需要改动的函数如下：
>
> ```kotlin
>     private fun createSampleTasks(): List<Task> {
>         val importantTasks: MutableList<Task> = ArrayList()
>         val cal = Calendar.getInstance()
> 
>         // Reset time to beginning of day
>         cal[Calendar.HOUR_OF_DAY] = 0
>         cal[Calendar.MINUTE] = 0
>         cal[Calendar.SECOND] = 0
>         cal[Calendar.MILLISECOND] = 0
> 
>         // 使用明确的十进制数字作为ID
>         val taskId = 12345678 // 8位数ID
> 
>         // 使用正确的时间范围格式: "HH : MM -- HH : MM"
>         importantTasks.add(
>             Task(
>                 taskId,
>                 "上课",
>                 "19 : 00 -- 21 : 00",
>                 cal.time,
>                 120,
>                 false,
>                 "这是一个任务的简介"
>             )
>         )
> 
>         return importantTasks
>     }
> ```
>
> 在这个函数中，我们使用了硬编码模拟用户的任务数据，现在需要进行如下改动：
>  （1）使用`tasks.GET("/users/:user_id/today", taskController.GetTasksForDay)`获取用户任务数据，这个api的格式为
>
> ```kotlin
>     // 按日期获取任务
>     @GET("api/tasks/users/{userId}/today")
>     suspend fun getTasksByDate(
>         @Path("userId") userId: String,
>         @Query("date") date: String
>     ): Response<List<TaskResponse>>
> ```
>
> （2）对获取的`TaskResponse`按照`"is_important":"true"`的条件进行筛选，然后进行以下操作：
>
> ```kotlin
>         importantTasks.add(
>             Task(
>                 taskId,//_id
>                 taskName,//title
>                 timeRange,//time_range
>                 cal.time,
>                 duration,//duration_minutes
>                 isFinished,//is_finished
>                 description //descripition
>             )
>         )
> ```
>
> 请修改函数，尽量不要修改MainActivity的其它部分。

7. 

> 感谢你的帮助，现在主页的内容已经基本完成了，最后需要对tasksState中的任务按起始时间进行排序。
>
> （文件）

8. 

> 你做得非常好。现在，你需要修改EditTaskActivity，以实现任务的编辑。
>  （1）你需要从MainActivity向EditTaskActivity传递id
>  （2）你需要在EditTaskActivity中使用以下api
>
> ```kotlin
>     // 获取任务详情
>     @GET("api/tasks/{taskId}")
>     suspend fun getTask(@Path("taskId") taskId: String): Response<TaskResponse>
> ```
>
> 将任务详情展示在页面中
>  （3）当用户调整任务详情后，你需要使用如下api
>
> ```kotlin
>     // 更新任务
>     @PUT("api/tasks/{taskId}")
>     suspend fun updateTask(
>         @Path("taskId") taskId: String,
>         @Body request: CreateTaskRequest
>     ): Response<TaskResponse>
> ```
>
> 收集用户的更改，并更新任务
>  （4）当用户删除任务时，你需要使用如下api
>
> ```kotlin
>     // 删除任务
>     @DELETE("api/tasks/{taskId}")
>     suspend fun deleteTask(@Path("taskId") taskId: String): Response<Map<String, String>>
> ```
>
> 从数据库中删除任务。
>
> （文件）

9. 

> 你做得非常好。现在，你需要修改ListViewActivity，以实现今日任务的展示。
>  （1）你需要使用以下api
>
> ```kotlin
>     // 按日期获取任务
>     @GET("api/tasks/users/{userId}/today")
>     suspend fun getTasksByDate(
>         @Path("userId") userId: String,
>         @Query("date") date: String
>     ): Response<List<TaskResponse>>
> ```
>
> 获取今日的所有任务
>  （2）你需要使用获取的任务替代我已经写好的样例
>  （3）TaskManager,TaskApiClient等文件请保持不变
>
> （文件）

10. 

> 感谢你的帮助。现在需要完成前端，以提供数据展示。
>  (1)GetFocusStatsForDay和GetTotalFocusStats已经完成，无需修复
>  (2)对于GetFocusDistribution，需要以热力图的形式展示日、周、月的分布情况
>  (3)其余前端功能暂时不用考虑
>  (4)如果需要，你可以采用compose形式绘图
>
> （文件）

11. 

> 感谢你的帮助。接下来的任务具有挑战性，请将KanbanViewActivity改为使用compose实现。
>
> ## content
>
> KanbanViewActivity的页面内容请参考(Kanban.png)
>  （1）上方为日期(DateView），展示当前日期、昨天的日期及明天的日期
>
> - 支持左右滑动，如现在展示的日期为（7,8,9），左滑后切换为（10,11,12），右滑后切换为（4,5,6）
> - 支持点击日期，进入当日详细视图（TodayViewActivity），你可以预留这个入口
>    （2）主要部分为事项展示区，按小时为纵坐标，按日期为横坐标划分区域。按日期和占用的时间将事项卡片放置在展示区内，对于没有指定时间的任务，在顶部设置一个区域进行展示
>    （3）对于每一个事项，采用卡片（TaskCard）进行展示
> - 卡片需要按照高度展示任务的信息：对于高度最短的卡片，展示任务名称即可；随高度增加，依次展示任务的名称、时间、地点
> - 支持点击卡片，传递任务id进入编辑任务视图（EditTaskActivity）
> - 支持预留复杂的拓展功能（例如拖动任务卡片，暂时不需要实现）
>    （4）对于页面右下角添加任务的按钮（+），点击后进入添加任务视图（AddTaskActivity）
>
> ## tips
>
> （1）你可以使用硬编码输入所需要的数据（例如任务信息），任务类的信息在Task.kt。
>  （2）其他代码（例如KanbanViewActivity）仅供参考，你不需要根据原有的代码实现页面内容。
>
> （文件）

12. 

> 感谢你的帮助。接下来的任务以我提供的KanbanViewActivity.kt文件为准
>
> # background
>
> 我已经实现了部分卡片的拖动功能，但是现在存在以下问题：
>  （1）未定义时间的任务没有显示，请按之前的要求，在顶端预留一片区域显示未定义时间的任务（只显示任务名称）；
>  （2）用户拖动任务卡片到新位置后，前端没有反馈。现在我希望**先更改前端显示的数据**（例如新的任务时间），再将改变后的数据传递至后端；
>  （3）现在的位置监测不准确（例如用户可以把卡片移动到一个随意的纵坐标，而非日期对应的区域内），请完善位置监测机制。
>  如果需要我提供其他文件，请在回答中说明。
>
> （文件）

13. 

> # fix
>
> 现在的问题在于，卡片在移动过程中能够正确计算改变的时间和日期，但是由于吸附函数可能采用了不正确的坐标系，当用户松手后，卡片会被放置到一个意外的位置。
>  因此，我们需要简化运算的逻辑，以避免频繁切换坐标系引发的问题。纵坐标是不需要改变的，因为用户松手的位置就是其期望的位置。但由于用户可能无法准确将卡片与日期对齐，需要略微调整纵坐标，以保持页面的美观。
>  现在，请将吸附的逻辑改为
>  （1）纵坐标：停止交互（用户松开手指）时的纵坐标
>  （2）横坐标：就近放入日期对应的横坐标（由于显示日期的数量不变，可以直接使用常量）
>  你只需要改进吸附相关的函数，不需要改变数据显示、冲突处理以及其他与数据相关的内容，因为目前的问题在于显示而非数据。

15. 

> 现在我希望在这个TODO_LIST代码中添加ai对话功能。详细的要求如下：
>
> ## backend
>
> （1）你需要拓展user类，在user类中新增一个成员`api_key`。这个`api_key`用来存储以下格式的api:`sk-27d5bc6ca6824cad8679e5e67e85b2ff`（示例）
>  （2）你需要在后端完成向ai服务商进行请求的api，我会提供一个调用api的例子，使用的是python语言，你需要将它调整成gin/gorm的形式
>
> （3）你需要新增一个api，用于从前端获取任务信息和用户添加的prompt
>  （4）你需要新增一个api，用于将用户的apikey添加到数据库里
>
> ## frontend
>
> （1）你需要在MainActivity的TaskItem添加一个按钮，用于进入和AI交互的界面
>  （2）你需要实现一个新界面，用于展示任务的详细信息并提供用户输入detailed_prompts的输入框，并且提示用户输入api_key（如果用户没有输入api_key）
>  （3）你需要在新界面中展示和AI的对话框，提供合适的输入和输出方式
>
> ## tips
>
> - 我希望你模拟成一个程序员，按照我提供的实现步骤修改每一个功能。
> - 要求每一步的更改都给出需要更改的部分的完整代码。
> - 同时我不希望你做任何额外的功能，只需要满足我的需求即可。
> - 如果你认为需要更多的提示文件，或者你认为有必要新建除新功能之外的文件（这可能由于我没有提供），请务必告知我。
>
> （文件）

#### 4.2.2 Chatgpt-o3

1. 

> 如何在Android Studio中将`<resources>  `    <string name="app_name">BIG</string> </resources>`替换为应用的多语言名称？`

2. 

> \## code
>
>  ```dependencies {    // 首先添加Kotlin BOM以确保一致的Kotlin版本    implementation(platform(libs.kotlin.bom))     // 现有依赖    implementation(libs.appcompat)    implementation(libs.material)    implementation(libs.activity)    implementation(libs.constraintlayout)    implementation(libs.circleimageview)    implementation(libs.mpandroidchart)    implementation(libs.core.ktx)    testImplementation(libs.junit)    androidTestImplementation(libs.ext.junit)    androidTestImplementation(libs.espresso.core)     // Compose 依赖    implementation(platform(libs.compose.bom))    implementation(libs.compose.ui)    implementation(libs.compose.ui.graphics)    implementation(libs.compose.ui.tooling.preview)    implementation(libs.compose.material3)    implementation(libs.activity.compose)    debugImplementation(libs.compose.ui.tooling)    debugImplementation(libs.compose.ui.test.manifest)     // Retrofit 用于网络请求    implementation(libs.retrofit)    implementation(libs.retrofit.converter.gson)    implementation(libs.okhttp.logging)     // ViewModel    implementation(libs.lifecycle.viewmodel.compose)    implementation(libs.compose.runtime.livedata)     // Coroutines    implementation(libs.kotlinx.coroutines.android) } ```
>
> ## task 
>
> 请将
>
> ```
> dependencies {
>     // Retrofit for API calls
>     implementation 'com.squareup.retrofit2:retrofit:2.9.0'
>     implementation 'com.squareup.retrofit2:converter-gson:2.9.0'
>     implementation 'com.squareup.okhttp3:okhttp:4.10.0'
>     implementation 'com.squareup.okhttp3:logging-interceptor:4.10.0'
>     
>     // Glide for image loading
>     implementation 'com.github.bumptech.glide:glide:4.15.1'
>     
>     // CircleImageView for round profile images
>     implementation 'de.hdodenhof:circleimageview:3.1.0'
>     
>     // Kotlin coroutines
>     implementation 'org.jetbrains.kotlinx:kotlinx-coroutines-android:1.7.1'
>     implementation 'androidx.lifecycle:lifecycle-runtime-ktx:2.6.1'
> }
> ```
>
> 以正确的格式添加到上方的dependencies中

3. 

> 我现在拥有一个使用Android Studio的原生Java语言应用，如果我希望迁移到jetpack框架，需要进行什么操作？

4. 

> 如何在wsl ubuntu 24.04中配置go语言和gin/gorm框架适用的环境？

